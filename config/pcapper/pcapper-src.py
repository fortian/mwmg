# CORE
# NRL 5520
# CORE service to setup PCapper monitoring at scenario start

import os
import sys
import json
import logging

from core.service import CoreService
from core.service import ServiceMode

class CaaS(CoreService):
    # a unique name is required, without spaces
    name = "PCAPper-Src"
    # you can create your own group here
    group = "ProtoSvc"
    # Any services that want to steal IP addresses from interfaces need a
    # dependency UPON this service, so that they don't get the address before we
    # can read it.
    # list of other services this service depends on
    dependencies = ()
    # validation check [Note: will detect PCapper instances from other services]
    validate = ('pgrep -x pcapper',)
    meta = "monitors network traffic and logs/reports to collector(s)"
    # validation time (defaults to 0.125 seconds) [N/A]
    # per-node directories [N/A]
    dirs = ("")
    # generated files (without a full path, this file goes in the node's dir,
    # e.g. /tmp/pycore.12345/n1.conf/)
    configs = (name + '.sh', )
    # list of startup commands, also may be generated during startup
    startup = ('sh ' + configs[0],)
    # list of shutdown commands
    # Note: This will clobber all PCAPper services, including those started by
    # another service.
    shutdown = ('pkill -x pcapper')

    @classmethod
    def generate_config(cls, node, filename):
        """
        Run PCapper agent only on routing nodes
        """
        # All systems are administratively declared to have an eth0 interface;
        # some systems have an eth1 as well.
        cmd = "#!/bin/sh\n# auto-generated by PCAPper-Src CORE service\n\n/usr/local/bin/pcapper -i eth0 -r br0 -p 7073 -f pcapper-src.eth0.log &\n"
        comments = ""
        if 'foo' in node.name:
            # This system is administratively supposed to have 2 interfaces.
            cmd += "/usr/local/bin/pcapper -i eth1 -r br1 -p 7074 -f pcapper-src.eth1.log &\n"
        return cmd
